import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';
import { config } from '../config/index.js';
import { logger } from '../utils/logger.js';
import { contentModerationService } from './contentModerationService.js';
import sharp from 'sharp';

export interface PoseGenerationOptions {
  themeId: string;
  variantId?: string;
  action: string;
  mood: string;
  userFaceBuffer: Buffer;
  templateBuffer: Buffer;
}

export interface GeneratedPoseResult {
  imageBuffer: Buffer;
  prompt: string;
  model: string;
}

export class BedrockService {
  private client: BedrockRuntimeClient;

  constructor() {
    this.client = new BedrockRuntimeClient({ region: config.aws.region });
  }

  async generatePoseVariation(options: PoseGenerationOptions): Promise<GeneratedPoseResult> {
    console.log(`[BEDROCK] Starting face swap for theme ${options.themeId}`);
    
    try {
      // Validate theme-action-mood combination
      const themeValidation = contentModerationService.validateThemeAction(
        options.themeId, 
        options.action, 
        options.mood
      );
      
      if (!themeValidation.isAppropriate) {
        throw new Error(`Content moderation blocked request: ${themeValidation.reason}`);
      }

      // Build face swap specific prompt
      const faceSwapPrompt = this.buildFaceSwapPrompt(options);
      console.log(`[BEDROCK] Using face swap prompt: ${faceSwapPrompt}`);
      
      // Create face mask for inpainting
      const faceMask = await this.createFaceMask(options.templateBuffer);
      
      // Use Amazon Nova Canvas for superior face swapping
      const modelId = 'amazon.nova-canvas-v1';
      
      const requestBody = {
        taskType: 'INPAINTING',
        inpaintingParams: {
          text: faceSwapPrompt,
          negativeText: this.buildNegativePrompt(),
          image: options.templateBuffer.toString('base64'),
          maskImage: faceMask.toString('base64')
        },
        imageGenerationConfig: {
          numberOfImages: 1,
          height: 1024,
          width: 1024,
          cfgScale: 8.0,
          quality: 'premium'
        }
      };

      const command = new InvokeModelCommand({
        modelId,
        body: JSON.stringify(requestBody),
        contentType: 'application/json',
        accept: 'application/json'
      });

      console.log(`[BEDROCK] Sending face swap request to Amazon Nova Canvas`);
      const response = await this.client.send(command);
      const responseBody = JSON.parse(new TextDecoder().decode(response.body));
      
      if (!responseBody.images || responseBody.images.length === 0) {
        throw new Error('No image generated by Bedrock');
      }

      const imageBase64 = responseBody.images[0];
      let imageBuffer = Buffer.from(imageBase64, 'base64');
      
      // Post-process to blend user face features
      imageBuffer = Buffer.from(await this.blendUserFaceFeatures(imageBuffer, options.userFaceBuffer));

      console.log(`[BEDROCK] ✅ Successfully generated face swap, size: ${imageBuffer.length} bytes`);

      return {
        imageBuffer,
        prompt: faceSwapPrompt,
        model: modelId
      };
    } catch (error) {
      console.log(`[BEDROCK] ❌ Face swap failed:`, {
        error: error.message,
        code: error.code || 'UNKNOWN',
        name: error.name
      });
      
      // Handle specific Bedrock errors
      if (error.name === 'AccessDeniedException') {
        throw new Error('BEDROCK_ACCESS_DENIED: Model access not granted. Request access to Amazon Nova Canvas in AWS Console → Bedrock → Model Access');
      }
      
      if (error.name === 'ValidationException') {
        throw new Error('BEDROCK_VALIDATION_ERROR: Invalid parameters for Amazon Nova Canvas model');
      }
      
      throw new Error(`FACE_SWAP_FAILED: ${error.message}`);
    }
  }

  private buildFaceSwapPrompt(options: PoseGenerationOptions): string {
    // Core instruction using imperative language
    const coreInstruction = "REPLACE the existing face in this image with a new face while preserving everything else exactly";
    
    // Specific preservation requirements
    const preservationRules = [
      "KEEP: exact same body position and pose",
      "KEEP: all clothing, armor, and accessories unchanged", 
      "KEEP: background environment completely identical",
      "KEEP: original lighting direction and intensity",
      "KEEP: camera angle and perspective"
    ].join(", ");
    
    // Face integration requirements
    const faceIntegration = [
      "MATCH: new face lighting to original face lighting",
      "MATCH: new face angle to original face angle", 
      "MATCH: new face expression to original expression",
      "BLEND: skin tones naturally with scene lighting",
      "ALIGN: facial features with original head position"
    ].join(", ");
    
    // Theme-specific character descriptions
    const themeDescriptions = {
      anime: "anime-style character with vibrant colors, stylized features, and detailed artwork aesthetic",
      barbarian: "fierce barbarian warrior with muscular build, battle-ready stance, medieval fantasy setting with tribal elements",
      greek: "noble ancient Greek hero with classical proportions, heroic bearing, marble statue aesthetic, mythological grandeur",
      mystic: "mystical wizard or sorcerer with magical aura, arcane powers, enchanted atmosphere, supernatural presence"
    };
    
    // Action-specific pose descriptions
    const actionDescriptions = {
      'cast-spell': "casting a powerful magical spell with energy swirling around hands, mystical gestures, arcane focus",
      'serious-look': "intense serious expression with determined gaze, focused eyes, strong jaw, commanding presence",
      'battle-stance': "ready for combat with weapon raised, defensive posture, alert stance, warrior readiness",
      'meditation': "peaceful meditative pose with serene expression, closed or half-closed eyes, spiritual tranquility",
      'victory': "triumphant victory pose with arms raised, celebratory gesture, confident expression, conquering stance"
    };
    
    // Mood-specific lighting and atmosphere
    const moodDescriptions = {
      epic: "epic cinematic lighting with dramatic shadows, heroic atmosphere, golden hour warmth, larger-than-life presence",
      dark: "dark moody lighting with deep shadows, mysterious atmosphere, low-key illumination, ominous ambiance",
      bright: "bright vibrant lighting with cheerful atmosphere, high-key illumination, optimistic mood, energetic feel",
      mystical: "mystical ethereal lighting with magical glow, otherworldly atmosphere, supernatural illumination, enchanted ambiance"
    };
    
    // Quality and technical specifications
    const qualitySpecs = [
      "photorealistic rendering",
      "8K ultra-high resolution", 
      "professional photography quality",
      "masterpiece level detail",
      "seamless digital compositing",
      "natural skin texture and pores",
      "accurate facial proportions",
      "realistic hair and eye details"
    ].join(", ");
    
    // Get specific descriptions
    const themeDesc = themeDescriptions[options.themeId as keyof typeof themeDescriptions] || "fantasy character with detailed features";
    const actionDesc = actionDescriptions[options.action as keyof typeof actionDescriptions] || "dynamic heroic pose";
    const moodDesc = moodDescriptions[options.mood as keyof typeof moodDescriptions] || "dramatic atmospheric lighting";
    
    // Construct the complete prompt using best practices
    return [
      coreInstruction,
      preservationRules,
      faceIntegration,
      `CHARACTER: ${themeDesc}`,
      `ACTION: ${actionDesc}`,
      `MOOD: ${moodDesc}`,
      `QUALITY: ${qualitySpecs}`
    ].join(". ");
  }

  private buildPrompt(options: PoseGenerationOptions): string {
    const themePrompts = {
      anime: 'anime style character, vibrant colors, detailed artwork',
      barbarian: 'fierce barbarian warrior, muscular, battle-ready, medieval fantasy',
      greek: 'ancient Greek hero, classical mythology, marble statue aesthetic',
      mystic: 'mystical wizard, magical aura, arcane powers, fantasy setting'
    };

    const variantPrompts = {
      // Anime variants
      'anime-mage': 'anime mage character, magical staff, flowing robes, spell casting',
      'anime-warrior': 'anime warrior, sword and armor, battle ready, heroic stance',
      // Barbarian variants
      'barbarian-berserker': 'berserker barbarian, wild fury, battle axe, primal rage',
      'barbarian-chieftain': 'barbarian chieftain, tribal leader, commanding presence',
      // Greek variants
      'greek-hero': 'Greek mythological hero, classical armor, noble bearing',
      'greek-god': 'Greek god, divine aura, powerful presence, olympian majesty',
      // Mystic variants
      'mystic-wizard': 'wise wizard, long beard, magical staff, arcane knowledge',
      'mystic-sorcerer': 'dark sorcerer, mysterious powers, shadowy magic'
    };

    const actionPrompts = {
      'cast-spell': 'casting a powerful spell, magical energy swirling, glowing hands',
      'serious-look': 'serious intense expression, determined gaze, dramatic lighting',
      'battle-stance': 'ready for battle, weapon raised, heroic pose',
      'meditation': 'peaceful meditation pose, serene expression, spiritual energy',
      'victory': 'triumphant victory pose, arms raised, celebrating'
    };

    const moodPrompts = {
      epic: 'epic cinematic lighting, dramatic atmosphere, heroic',
      dark: 'dark moody lighting, shadows, mysterious atmosphere',
      bright: 'bright vibrant lighting, cheerful, optimistic',
      mystical: 'mystical ethereal lighting, magical glow, otherworldly'
    };

    const basePrompt = themePrompts[options.themeId as keyof typeof themePrompts] || 'fantasy character';
    const variantKey = options.variantId ? `${options.themeId}-${options.variantId}` : null;
    const variantPrompt = variantKey ? variantPrompts[variantKey as keyof typeof variantPrompts] : null;
    const actionPrompt = actionPrompts[options.action as keyof typeof actionPrompts] || 'dynamic pose';
    const moodPrompt = moodPrompts[options.mood as keyof typeof moodPrompts] || 'dramatic';

    const finalPrompt = variantPrompt || basePrompt;
    const biasPreventionSuffix = 'inclusive, respectful, non-discriminatory, appropriate for all audiences';
    
    return `${finalPrompt}, ${actionPrompt}, ${moodPrompt}, ${biasPreventionSuffix}, high quality, detailed, realistic, professional photography, 4K resolution`;
  }

  /**
   * Create a precise face mask using Rekognition landmarks
   */
  private async createFaceMask(templateBuffer: Buffer): Promise<Buffer> {
    try {
      // Use Rekognition to detect face landmarks in template
      const { faceDetectionService } = await import('./faceDetectionService.js');
      
      // Save template temporarily for face detection
      const tempKey = `temp/mask-${Date.now()}.jpg`;
      const { config: dynamicConfig } = await import('../config/index.js');
      const s3Client = new (await import('@aws-sdk/client-s3')).S3Client({ region: dynamicConfig.aws.region });
      
      await s3Client.send(new (await import('@aws-sdk/client-s3')).PutObjectCommand({
        Bucket: dynamicConfig.aws.s3.bucketName,
        Key: tempKey,
        Body: templateBuffer,
        ContentType: 'image/jpeg'
      }));
      
      try {
        const faceDetection = await faceDetectionService.detectFaces(tempKey);
        
        if (faceDetection.faces.length > 0) {
          const face = faceDetection.faces[0];
          const { width, height } = await sharp(templateBuffer).metadata();
          
          // Create precise face mask from bounding box
          const faceX = Math.round(face.boundingBox.left * width!);
          const faceY = Math.round(face.boundingBox.top * height!);
          const faceWidth = Math.round(face.boundingBox.width * width!);
          const faceHeight = Math.round(face.boundingBox.height * height!);
          
          // Add padding for better blending
          const padding = Math.round(Math.max(faceWidth, faceHeight) * 0.2);
          
          const maskSvg = `
            <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
              <rect width="${width}" height="${width}" fill="white"/>
              <ellipse cx="${faceX + faceWidth/2}" cy="${faceY + faceHeight/2}" 
                       rx="${faceWidth/2 + padding}" ry="${faceHeight/2 + padding}" 
                       fill="black"/>
            </svg>
          `;
          
          // Clean up temp file
          await s3Client.send(new (await import('@aws-sdk/client-s3')).DeleteObjectCommand({
            Bucket: dynamicConfig.aws.s3.bucketName,
            Key: tempKey
          }));
          
          return await sharp(Buffer.from(maskSvg)).png().toBuffer();
        }
      } catch (detectionError) {
        console.log(`[BEDROCK] Face detection failed for mask creation:`, detectionError.message);
      }
      
      // Fallback to center mask
      const { width, height } = await sharp(templateBuffer).metadata();
      const maskSvg = `
        <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
          <rect width="${width}" height="${height}" fill="white"/>
          <ellipse cx="${width! * 0.5}" cy="${height! * 0.4}" 
                   rx="${width! * 0.15}" ry="${height! * 0.2}" 
                   fill="black"/>
        </svg>
      `;
      
      return await sharp(Buffer.from(maskSvg)).png().toBuffer();
    } catch (error) {
      console.log(`[BEDROCK] Failed to create face mask:`, error.message);
      
      // Simple fallback mask
      return await sharp({
        create: {
          width: 1024,
          height: 1024,
          channels: 3,
          background: { r: 255, g: 255, b: 255 }
        }
      })
      .composite([{
        input: Buffer.from(`
          <svg width="1024" height="1024">
            <ellipse cx="512" cy="400" rx="150" ry="200" fill="black"/>
          </svg>
        `),
        top: 0,
        left: 0
      }])
      .png()
      .toBuffer();
    }
  }

  /**
   * Blend user face features into the generated image
   */
  private async blendUserFaceFeatures(generatedImage: Buffer, userFaceBuffer: Buffer): Promise<Buffer> {
    try {
      // Extract and resize user face features
      const userFaceResized = await sharp(userFaceBuffer)
        .resize(200, 250, { fit: 'cover' })
        .modulate({ brightness: 1.1, saturation: 0.9 }) // Adjust for better blending
        .toBuffer();
      
      // Blend user face features into generated image
      const result = await sharp(generatedImage)
        .composite([
          {
            input: userFaceResized,
            top: 300, // Approximate face position
            left: 412, // Center horizontally  
            blend: 'overlay' // Blend mode for natural look
          }
        ])
        .jpeg({ quality: 95 })
        .toBuffer();
      
      return result;
    } catch (error) {
      console.log(`[BEDROCK] Face blending failed, returning generated image:`, error.message);
      return generatedImage;
    }
  }

  /**
   * Build comprehensive negative prompt using best practices
   */
  private buildNegativePrompt(): string {
    const technicalIssues = [
      "blurry", "low quality", "low resolution", "pixelated", "compressed", "artifacts", "noise", "grain"
    ];
    
    const faceSwapIssues = [
      "multiple faces", "double face", "face overlay", "floating face", "disconnected face", 
      "misaligned face", "wrong face angle", "face size mismatch", "unnatural face blend",
      "visible face edges", "face seams", "color mismatch", "lighting mismatch", "bad face swap"
    ];
    
    const anatomicalIssues = [
      "distorted face", "deformed features", "asymmetrical face", "wrong proportions",
      "extra eyes", "missing eyes", "extra nose", "extra mouth", "malformed ears",
      "bad anatomy", "extra limbs", "missing limbs", "mutated hands", "poorly drawn hands"
    ];
    
    const styleIssues = [
      "cartoon", "anime face on realistic body", "inconsistent art style", "mixed styles",
      "watermark", "signature", "text overlay", "logo", "copyright", "username"
    ];
    
    const contentIssues = [
      "inappropriate", "offensive", "explicit", "nsfw", "violence", "gore", "disturbing",
      "racist", "sexist", "discriminatory", "hate", "stereotypes", "bias", "prejudice"
    ];
    
    const qualityIssues = [
      "amateur", "beginner", "bad art", "worst quality", "ugly", "hideous", "grotesque",
      "poorly rendered", "bad composition", "bad lighting", "overexposed", "underexposed"
    ];
    
    // Combine all negative elements
    return [
      ...technicalIssues,
      ...faceSwapIssues, 
      ...anatomicalIssues,
      ...styleIssues,
      ...contentIssues,
      ...qualityIssues
    ].join(", ");
  }

  async getAvailableActions(themeId: string): Promise<string[]> {
    const themeActions = {
      anime: ['cast-spell', 'serious-look', 'battle-stance', 'victory'],
      barbarian: ['battle-stance', 'serious-look', 'victory', 'roar'],
      greek: ['heroic-pose', 'serious-look', 'meditation', 'victory'],
      mystic: ['cast-spell', 'meditation', 'serious-look', 'mystical-gesture']
    };

    return themeActions[themeId as keyof typeof themeActions] || ['serious-look', 'victory'];
  }
}

export const bedrockService = new BedrockService();