/**
 * Security-focused Infrastructure Tests
 * Tests security configurations and compliance
 */

import { App } from 'aws-cdk-lib';
import { Template, Match } from 'aws-cdk-lib/assertions';
import { PhotoboothStack } from '../src/stacks/photobooth-stack';

describe('Security Infrastructure Tests', () => {
  let app: App;
  let stack: PhotoboothStack;
  let template: Template;

  beforeEach(() => {
    app = new App();
    stack = new PhotoboothStack(app, 'SecurityTestStack', {
      environmentConfig: {
        environment: 'test',
        region: 'us-east-1',
        enableWaf: true,
        enableXRay: true,
        logRetentionDays: 7,
        autoScaling: {
          minCapacity: 1,
          maxCapacity: 3,
          targetCpuUtilization: 70,
          targetMemoryUtilization: 80,
          scaleOutCooldown: 300,
          scaleInCooldown: 300,
        },
        s3: {
          uploadRetentionDays: 1,
          processedRetentionDays: 3,
        },
        monitoring: {
          enableDetailedMonitoring: true,
        },
        performance: {
          connectionPoolSize: 10,
          maxConcurrentProcessing: 20,
          processingTimeoutMs: 15000,
        },
      },
    });
    template = Template.fromStack(stack);
  });

  describe('S3 Security Configuration', () => {
    it('should block all public access', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        PublicAccessBlockConfiguration: {
          BlockPublicAcls: true,
          BlockPublicPolicy: true,
          IgnorePublicAcls: true,
          RestrictPublicBuckets: true,
        },
      });
    });

    it('should enable server-side encryption', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        BucketEncryption: {
          ServerSideEncryptionConfiguration: Match.arrayWith([
            {
              ServerSideEncryptionByDefault: {
                SSEAlgorithm: 'AES256',
              },
              BucketKeyEnabled: true,
            },
          ]),
        },
      });
    });

    it('should enforce SSL/TLS for all requests', () => {
      template.hasResourceProperties('AWS::S3::BucketPolicy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Deny',
              Principal: '*',
              Action: 's3:*',
              Resource: Match.anyValue(),
              Condition: {
                Bool: {
                  'aws:SecureTransport': 'false',
                },
              },
            }),
          ]),
        },
      });
    });
  });

  describe('IAM Security Configuration', () => {
    it('should use least privilege principle for ECS task role', () => {
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Action: Match.not(Match.arrayWith(['*'])), // Should not have wildcard permissions
            }),
          ]),
        },
      });
    });

    it('should not allow cross-account access without conditions', () => {
      const policies = template.findResources('AWS::IAM::Policy');
      
      Object.values(policies).forEach((policy: any) => {
        const statements = policy.Properties?.PolicyDocument?.Statement || [];
        statements.forEach((statement: any) => {
          if (statement.Principal && typeof statement.Principal === 'object') {
            // If there's a cross-account principal, there should be conditions
            if (statement.Principal.AWS && Array.isArray(statement.Principal.AWS)) {
              statement.Principal.AWS.forEach((arn: string) => {
                if (arn.includes(':root')) {
                  expect(statement.Condition).toBeDefined();
                }
              });
            }
          }
        });
      });
    });

    it('should require MFA for sensitive operations', () => {
      // Check for MFA conditions in policies that allow destructive actions
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Action: Match.arrayWith(['s3:DeleteObject']),
              Condition: {
                Bool: {
                  'aws:MultiFactorAuthPresent': 'true',
                },
              },
            }),
          ]),
        },
      });
    });
  });

  describe('Network Security Configuration', () => {
    it('should create security groups with minimal required access', () => {
      template.hasResourceProperties('AWS::EC2::SecurityGroup', {
        SecurityGroupIngress: Match.arrayWith([
          Match.objectLike({
            IpProtocol: 'tcp',
            FromPort: Match.anyValue(),
            ToPort: Match.anyValue(),
            CidrIp: Match.absent(), // Should not allow 0.0.0.0/0 access
            SourceSecurityGroupId: Match.anyValue(), // Should reference other security groups
          }),
        ]),
      });
    });

    it('should not allow SSH access from internet', () => {
      const securityGroups = template.findResources('AWS::EC2::SecurityGroup');
      
      Object.values(securityGroups).forEach((sg: any) => {
        const ingressRules = sg.Properties?.SecurityGroupIngress || [];
        ingressRules.forEach((rule: any) => {
          if (rule.FromPort === 22 || rule.ToPort === 22) {
            expect(rule.CidrIp).not.toBe('0.0.0.0/0');
          }
        });
      });
    });

    it('should use HTTPS/TLS for all external communication', () => {
      template.hasResourceProperties('AWS::ElasticLoadBalancingV2::Listener', {
        Protocol: 'HTTPS',
        Port: 443,
      });
    });
  });

  describe('Data Encryption Configuration', () => {
    it('should encrypt DynamoDB tables at rest', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        SSESpecification: {
          SSEEnabled: true,
        },
      });
    });

    it('should encrypt ECS task logs', () => {
      template.hasResourceProperties('AWS::Logs::LogGroup', {
        KmsKeyId: Match.anyValue(), // Should have KMS key for encryption
      });
    });

    it('should use encrypted communication for ECS tasks', () => {
      template.hasResourceProperties('AWS::ECS::TaskDefinition', {
        ContainerDefinitions: Match.arrayWith([
          Match.objectLike({
            Environment: Match.arrayWith([
              Match.objectLike({
                Name: 'FORCE_HTTPS',
                Value: 'true',
              }),
            ]),
          }),
        ]),
      });
    });
  });

  describe('Compliance and Auditing', () => {
    it('should enable CloudTrail logging', () => {
      // Note: CloudTrail might be configured at account level
      // This test ensures our resources support auditing
      template.hasResourceProperties('AWS::S3::Bucket', {
        NotificationConfiguration: {
          CloudWatchConfigurations: Match.arrayWith([
            Match.objectLike({
              Event: 's3:ObjectCreated:*',
            }),
          ]),
        },
      });
    });

    it('should tag all resources for compliance tracking', () => {
      const resources = template.findResources('AWS::S3::Bucket');
      
      Object.values(resources).forEach((resource: any) => {
        expect(resource.Properties?.Tags).toBeDefined();
        
        const tags = resource.Properties.Tags || [];
        const hasEnvironmentTag = tags.some((tag: any) => tag.Key === 'Environment');
        const hasProjectTag = tags.some((tag: any) => tag.Key === 'Project');
        
        expect(hasEnvironmentTag).toBe(true);
        expect(hasProjectTag).toBe(true);
      });
    });

    it('should configure resource-level permissions', () => {
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Resource: Match.not('*'), // Should not use wildcard resources
            }),
          ]),
        },
      });
    });
  });

  describe('Secrets Management', () => {
    it('should not expose sensitive data in environment variables', () => {
      const taskDefinitions = template.findResources('AWS::ECS::TaskDefinition');
      
      Object.values(taskDefinitions).forEach((taskDef: any) => {
        const containers = taskDef.Properties?.ContainerDefinitions || [];
        containers.forEach((container: any) => {
          const environment = container.Environment || [];
          environment.forEach((envVar: any) => {
            // Check that sensitive data is not in plain text
            const sensitivePatterns = [
              /password/i,
              /secret/i,
              /key/i,
              /token/i,
            ];
            
            if (sensitivePatterns.some(pattern => pattern.test(envVar.Name))) {
              // Should use Secrets Manager or Parameter Store
              expect(envVar.ValueFrom).toBeDefined();
            }
          });
        });
      });
    });

    it('should use AWS Secrets Manager for database credentials', () => {
      // If we had RDS, we would check for Secrets Manager integration
      // For now, ensure ECS tasks can access Secrets Manager
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Action: Match.arrayWith([
                'secretsmanager:GetSecretValue',
              ]),
              Resource: Match.stringLikeRegexp('arn:aws:secretsmanager:.*'),
            }),
          ]),
        },
      });
    });
  });

  describe('Security Monitoring', () => {
    it('should create CloudWatch alarms for security events', () => {
      template.hasResourceProperties('AWS::CloudWatch::Alarm', {
        MetricName: 'UnauthorizedAPICalls',
        Namespace: 'CWLogs',
        ComparisonOperator: 'GreaterThanThreshold',
        Threshold: 0,
      });
    });

    it('should configure VPC Flow Logs', () => {
      // Ensure VPC has flow logs enabled for security monitoring
      template.hasResourceProperties('AWS::EC2::FlowLog', {
        ResourceType: 'VPC',
        TrafficType: 'ALL',
      });
    });

    it('should enable GuardDuty integration', () => {
      // Check that resources are configured to work with GuardDuty
      template.hasResourceProperties('AWS::S3::Bucket', {
        NotificationConfiguration: {
          CloudWatchConfigurations: Match.arrayWith([
            Match.objectLike({
              Event: 's3:ObjectCreated:*',
            }),
          ]),
        },
      });
    });
  });

  describe('Incident Response', () => {
    it('should configure automated response to security events', () => {
      template.hasResourceProperties('AWS::CloudWatch::Alarm', {
        AlarmActions: Match.arrayWith([
          Match.stringLikeRegexp('arn:aws:sns:.*'), // Should trigger SNS for incident response
        ]),
      });
    });

    it('should enable resource isolation capabilities', () => {
      // Ensure security groups can be modified for isolation
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Action: Match.arrayWith([
                'ec2:AuthorizeSecurityGroupIngress',
                'ec2:RevokeSecurityGroupIngress',
              ]),
              Condition: {
                StringEquals: {
                  'aws:RequestedRegion': Match.anyValue(),
                },
              },
            }),
          ]),
        },
      });
    });
  });

  describe('Backup and Recovery Security', () => {
    it('should encrypt backups', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        PointInTimeRecoverySpecification: {
          PointInTimeRecoveryEnabled: true,
        },
        SSESpecification: {
          SSEEnabled: true,
        },
      });
    });

    it('should configure secure backup access', () => {
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Action: Match.arrayWith([
                'dynamodb:CreateBackup',
                'dynamodb:RestoreTableFromBackup',
              ]),
              Condition: {
                StringEquals: {
                  'aws:RequestedRegion': Match.anyValue(),
                },
              },
            }),
          ]),
        },
      });
    });
  });
});